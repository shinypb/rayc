<!DOCTYPE html>
<html>
  <body>
    <canvas id="c"></canvas>
    <canvas id="viewport"></canvas>
  </body>
  <script>console.log('----------', new Date);</script>
  <script id="rconst">
    window.RConst = {
      kBlockSize: 32,

      //  Visual appearance
      kBlockColor: '#bbb',
      kGridColor: '#ccc',
      kPointFill: 'rgba(0, 0, 200, 0.25)',
      kPointStroke: 'rgba(0, 0, 50, 0.75)',
      kPointRadius: 8,

      // Key codes
      kKeyLeft: 37,
      kKeyUp: 38,
      kKeyRight: 39,
      kKeyDown: 40,

      // 3D rendering
      kFieldOfViewDegrees: 160,
      kViewportHeight: 240,
      kViewportWidth: 320,

      // Player movement
      kIncrementRotate: 2,
      kIncrementMove: 2,
    };

  </script>
  <script id="rmap">

    window.RMap = function(mapName) {
      this.isSolidBlockCoords = function(x, y) {
        var index = (y * this.width) + x;
        return this.solidityMap[index];
      };

      this.isSolidPxCoords = function(xPx, yPx) {
        return this.isSolidBlockCoords(Math.floor(xPx / RConst.kBlockSize), Math.floor(yPx / RConst.kBlockSize));
      };

      this.distanceToIntersect = function(x, y, radAngle) {
        var rayLength = 1;
        while(rayLength < this.maxRayLength) {
          //  calculate next block
          var nextX = x + (rayLength * Math.sin(radAngle));
          var nextY = y + (rayLength * Math.cos(radAngle));
          if (this.isSolidPxCoords(nextX, nextY)) {

            if (false) {
              // Ray max extend into a solid block; cut it off at the edges
              var destBlockLeft = Math.floor(nextX / RConst.kBlockSize) * RConst.kBlockSize;
              var destBlockTop  = Math.floor(nextY / RConst.kBlockSize) * RConst.kBlockSize;
              var rayHitX, rayHitY;
              if (x < nextX) {
                rayHitX = destBlockLeft;
              } else {
                rayHitX = destBlockLeft + RConst.kBlockSize;
              };
              if (y < nextY) {
                rayHitY = destBlockTop;
              } else {
                rayHitY = destBlockTop + RConst.kBlockSize;
              };
              rCanvas.drawPoint(rayHitX, rayHitY);

              return distanceBetweenPoints(x, y, rayHitX, rayHitY);
            } else {
              // lazy/easy way
              return RMath.distanceBetweenPoints(x, y, nextX, nextY);
            };
          };

          rayLength += 1 ; // would prefer to use RConst.kBlockSize / 2;
        };

        throw 'Unable to find an intersection';
      };


      this.init = function() {
        /**
         *  Maps are defined with arrays like this:
         *  [
         *    '111',
         *    '101',
         *    '111'
         *  ]
         *  Blocks containing '1' are walls, everything else is floor.
         *
         *  This function transforms that structure into an array with one boolean per block:
         *  [
         *    true, true, true,
         *    true, false, true,
         *    true, true, true
         *  ]
         *
         */
        var rawMapData = RMaps[mapName]
        this.solidityMap = rawMapData.map(function(row) {
          return row.replace(/\s/g, '').split('').map(function(elem) {
            return elem == '#';
          });
        }).reduce(function(acc, elem) {
          return acc.concat(elem);
        }, [])

        this.height = rawMapData.length;
        this.width = this.solidityMap.length / this.height;
        this.maxRayLength = Math.ceil(Math.sqrt(Math.pow(this.height, 2) + Math.pow(this.width, 2))) * RConst.kBlockSize;
        console.log('World is', this.width, 'x', this.height, 'so ray length is', this.maxRayLength);
      };

      this.init();
    };

    window.RMaps = {
      demo1: [
        "# # # # # # # # # #",
        "# # - - - - - - - #",
        "# - # - - - # - - #",
        "# - - - - - - - - #",
        "# - - - - - - - - #",
        "# - - - - - - - - #",
        "# - - - - - - - - #",
        "# - # - - - - - - #",
        "# - # - - - - - - #",
        "# # # # # # # # # #",
      ]
    };


  </script>
  <script id="rmath">
    window.RMath = {
      deg2rad: function(angle) {
        return (angle * Math.PI) / 180;
      },

      distanceBetweenPoints: function (x1, y1, x2, y2) {
        return Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      },
    };
  </script>
  <script>
    (function() {


      var RCanvas = function(canvasElem, backgroundColor, width, height) {

        this.width = width;
        this.height = height;
        canvasElem.width = width;
        canvasElem.height = height;

        var context = canvasElem.getContext('2d');
        this.context = context;
        this.elem = canvasElem;

        this.backgroundColor = backgroundColor;

        this.clear = function() {
          this.fillRect(0, 0, this.width, this.height, this.backgroundColor);
        };

        this.fillRect = function(x, y, h, w, color) {
          if (color) {
            context.fillStyle = color;
          };
          context.fillRect(x, y, h, w);
        };

        this.drawLine = function(x1, y1, x2, y2) {
          context.beginPath();
          context.moveTo(x1, y1);
          context.lineTo(x2, y2);
          context.closePath();
          context.stroke();
        };

        this.drawVector = function(startX, startY, radAngle, length) {
          var stopX = startX + (length * Math.sin(radAngle));
          var stopY = startY + (length * Math.cos(radAngle));

          this.drawLine(startX, startY, stopX, stopY);
        };


        this.drawPoint = function(x, y) {
          context.beginPath();
          context.arc(x, y, RConst.kPointRadius, 0, 2 * Math.PI, false);
          context.fillStyle = RConst.kPointFill;
          context.fill();

          context.beginPath();
          context.arc(x, y, 1, 0, 2 * Math.PI, false);
          context.lineWidth = 1;
          context.strokeStyle = RConst.kPointStroke;
          context.stroke();
        };
      };

      var RWorld = function(rCanvas, map) {
        this.drawBlocks = function() {
          for(var i = 0; i < map.solidityMap.length; i++) {
            if (map.solidityMap[i]) {
              var x = i % map.width;
              var y = (i - x) / map.width;
              rCanvas.fillRect(x * RConst.kBlockSize, y * RConst.kBlockSize, RConst.kBlockSize, RConst.kBlockSize, RConst.kBlockColor);
            }
          };
        };

        this.drawGrid = function() {
          rCanvas.context.strokeStyle = RConst.kGridColor;
          if (rCanvas.height != rCanvas.width) {
            throw "drawGrid expects a square canvas";
          };
          for(var i = 0; i < rCanvas.width; i += RConst.kBlockSize) {
            rCanvas.drawLine(i, 0, i, rCanvas.height - 1);
            rCanvas.drawLine(0, i, rCanvas.width - 1, i);
          };
        };

        this.draw = function() {
          if (this.bufferCanvas) {
            rCanvas.context.drawImage(this.bufferCanvas, 0, 0);
            return;
          };

          // Draw the world
          this.drawGrid();
          this.drawBlocks();

          // Copy it to the backing store
          this.bufferCanvas = document.createElement('canvas');
          this.bufferCanvas.height = rCanvas.height;
          this.bufferCanvas.width = rCanvas.width;
          window.bs = this.bufferCanvas;
          var bufferCanvasContext = this.bufferCanvas.getContext('2d');
          bufferCanvasContext.drawImage(rCanvas.elem, 0, 0);
        };

        this.init = function() {
        };

        this.init();
      };

      var RPlayer = function(rCanvas, rMap, startX, startY, startingViewAngle) {
        this.x = startX;
        this.y = startY;
        this.viewAngle = startingViewAngle;

        this.keyMap = {};

        window.addEventListener('keydown', function(e) {
          this.keyMap[e.keyCode] = true;
        }.bind(this));
        window.addEventListener('keyup', function(e) {
          this.keyMap[e.keyCode] = false;
        }.bind(this));

        this.draw = function() {
          //  Draw player
          rCanvas.drawPoint(this.x, this.y);

          //  See what ray hits
          var rayLength = rMap.distanceToIntersect(this.x, this.y, RMath.deg2rad(this.viewAngle));

          //  Draw ray
          rCanvas.context.strokeStyle = 'red';
          rCanvas.drawVector(this.x, this.y, RMath.deg2rad(this.viewAngle), rayLength);
        };

        this.tick = function() {
          if (this.keyMap[RConst.kKeyLeft]) {
            this.viewAngle = (360 + (this.viewAngle + RConst.kIncrementRotate)) % 360;
          } else if (this.keyMap[RConst.kKeyRight]) {
            this.viewAngle = (360 + (this.viewAngle - RConst.kIncrementRotate)) % 360;
          };

          if (this.keyMap[RConst.kKeyUp]) {
            this.x += RConst.kIncrementMove * Math.sin(RMath.deg2rad(this.viewAngle));
            this.y += RConst.kIncrementMove * Math.cos(RMath.deg2rad(this.viewAngle));
          } else if (this.keyMap[RConst.kKeyDown]) {
            this.x -= RConst.kIncrementMove * Math.sin(RMath.deg2rad(this.viewAngle));
            this.y -= RConst.kIncrementMove * Math.cos(RMath.deg2rad(this.viewAngle));
          };
        };
      };

      var RViewport = function(mapRCanvas, viewportRCanvas, rPlayer, rMap) {
        var halfFieldOfViewDegrees = RConst.kFieldOfViewDegrees / 2;
        this.draw = function() {
          mapRCanvas.context.strokeStyle = 'lightblue';
          viewportRCanvas.context.strokeStyle = 'white';

          var minAngle = rPlayer.viewAngle - halfFieldOfViewDegrees;
          for(var x = 0; x < RConst.kViewportWidth; x++) {
            var angle = minAngle + ((x / RConst.kViewportWidth) * RConst.kFieldOfViewDegrees);

            var rayLength = rMap.distanceToIntersect(rPlayer.x, rPlayer.y, RMath.deg2rad(angle));

            //  Draw the vector in the top-down view
            mapRCanvas.drawVector(rPlayer.x, rPlayer.y, RMath.deg2rad(angle), rayLength);

            //  Draw the column in the viewport
            var wallHeight = (1 - (rayLength / rMap.maxRayLength)) * RConst.kViewportHeight;
            var wallY = RConst.kViewportHeight / 2 - wallHeight / 2;
            var wallColor = Math.floor((1 - (rayLength / rMap.maxRayLength)) * 255);
            viewportRCanvas.context.strokeStyle = 'rgb(' + [wallColor, wallColor, wallColor].join(',') + ')';
            viewportRCanvas.drawLine(RConst.kViewportWidth - x, wallY, RConst.kViewportWidth - x, RConst.kViewportHeight - wallY);
          };
        };

      };

      var Rayc = {
        init: function(mapCanvasSel, viewportCanvasSel) {
          console.log("init");

          this.draw = function() {
            this.mapRCanvas.clear();
            this.viewportRCanvas.clear();

            this.rPlayer.tick();

            this.rWorld.draw();
            this.rViewport.draw();
            this.rPlayer.draw();
          };

          this.tick = function() {
            if (this.lastTick) {
//               if (Math.random() * 100 < 1)  {
//                 document.title = Math.floor(1000 / ((new Date) - this.lastTick));
//               }
            };
            this.lastTick = new Date;
            this.draw();

            setTimeout(function() {
              requestAnimationFrame(this.tick.bind(this));
            }.bind(this), 0);
          };

          this.init = function() {
            this.rMap = new RMap('demo1');

            this.mapCanvasElem = document.querySelector(mapCanvasSel);
            this.mapRCanvas = new RCanvas(this.mapCanvasElem, '#eee', this.rMap.width * RConst.kBlockSize, this.rMap.height * RConst.kBlockSize);
//            this.mapRCanvas.d = true;

            this.viewportCanvasElem = document.querySelector(viewportCanvasSel);
            this.viewportRCanvas = new RCanvas(this.viewportCanvasElem, 'black', RConst.kViewportWidth, RConst.kViewportHeight);

            this.rWorld = new RWorld(this.mapRCanvas, this.rMap);
            this.viewportCanvasElem.width = RConst.kViewportWidth;
            this.viewportCanvasElem.height = RConst.kViewportHeight;

            this.rPlayer = new RPlayer(
              this.mapRCanvas,
              this.rMap,
              64, 128,
              112
            );
            this.rViewport = new RViewport(
              this.mapRCanvas,
              this.viewportRCanvas,
              this.rPlayer,
              this.rMap
            );

            this.tick();
          };

          this.init();
        },
      };

      Rayc.init('canvas#c', 'canvas#viewport');


    })();
  </script>
</html>
